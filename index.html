<html>
    <head>
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.css">
        <title>Understanding Fourier Approximations</title>
    </head>
    <body ng-app="Fourier" fourier-app ng-cloak>
         <md-content>
            <md-toolbar>
                <div class="md-toolbar-tools">
                   <md-button class="md-icon-button" aria-label="Settings">
                    <md-icon class="md-icon-button">timeline</md-icon>
                   </md-button>
                    <h2>
                        <span> Understanding Fourier Approximations</span>
                    </h2>
                    <span flex></span>
                    <md-button ng-click="app.status.visualizationPaused = !app.status.visualizationPaused" class="md-icon-button" aria-label="PlayPause">
                        <md-icon>{{!app.status.visualizationPaused? 'pause':'play_arrow'}}</md-icon>
                    </md-button>
                    <md-button ng-disabled="!app.status.visualizationPaused" ng-mousedown="app.status.step = true" class="md-icon-button" aria-label="Next">
                        <md-icon>skip_next</md-icon>
                    </md-button>
                    <md-button ng-click="app.status.audioPaused = !app.status.audioPaused" class="md-icon-button" aria-label="Mute" id="playpause">
                         <md-icon>{{!app.status.audioPaused? 'volume_off': 'volume_up'}}</md-icon>
                    </md-button>
                </div>
            </md-toolbar>
            <div layout layout-margin layout-padding layout-align="center stretch">
                <div layout flex="25">
                    <div flex layout layout-align="center center">
                        <md-input-container>
                            <label>Waveform</label>
                            <md-select ng-model="app.options.wave">
                                <md-option ng-repeat="wave in app.waves" ng-value="wave">
                                {{wave.name}}
                                </md-option>
                            </md-select>
                        </md-input-container>
                    </div>
                </div>
                <div layout flex="25">
                    <div flex="40" layout layout-align="center center">
                        <span flex>N = {{app.options.evaluation.value}}</span>
                    </div>
                    <div flex layout layout-align="center center">
                        <md-slider aria-label="F number" flex min="{{app.options.evaluation.min}}" max="{{app.options.evaluation.max}}" step="{{app.options.evaluation.step}}" ng-model="app.options.evaluation.value">
                        </md-slider>
                    </div>
                </div>
                <div layout flex="25">
                    <div flex layout layout-align="center center">
                        <md-switch ng-model="app.options.useLanczosFactor" aria-label="Switch 1">
                        Use Lanczos Sigma Factor?
                        </md-switch>
                    </div>
                </div>
                <div layout flex="25">
                    <div flex="20" layout layout-align="center center">
                        <span flex>Rate:</span>
                    </div>
                    <div flex layout layout-align="center center">
                        <md-slider aria-label="F number" flex min="60" max="12000" step="1" ng-model="app.options.rate">
                        </md-slider>
                    </div>
                </div>
            </div>
            <div layout="row" layout-align="center center">
                <div fourier-canvas=""></div>
            </div>
            <div style="padding: 20px;">
                P to pause, right arrow to step when paused, <a href="https://upload.wikimedia.org/wikipedia/commons/1/1a/Fourier_series_square_wave_circles_animation.gif">inspiration, here</a><br><br>
            </div>
        </md-content>
        <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-aria.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-messages.min.js"></script>

        <!-- Angular Material Library -->
        <script src="http://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.js"></script>
        
        <!-- Your application bootstrap  -->
        <script type="text/javascript"> 
        var frametimes = [];  
        frametimes.result = () => {
            var result = frametimes.reduce( (prev, curr) => prev + curr ) / frametimes.length;
            frametimes.length = 0; 
            return result;
        };   
            /**
             * You must include the dependency on 'ngMaterial' 
             */
            angular.module('Fourier', ['ngMaterial'])
            .config(function($mdThemingProvider) {
                $mdThemingProvider.theme('default')
                    .primaryPalette('teal')
                    .accentPalette('indigo');
                })
            .directive('fourierApp', function() {
                
                return {
                  controller: FourierAppCtrl,
                  controllerAs: 'app',
                  link: FourierAppLink,
                  bindToController: true
                };
                
                
                function FourierAppCtrl($scope) {
                    
                    this.options = {
                        evaluation: {
                            min: 1,
                            max: 63,
                            step: 2,
                            value: 1
                        },
                        useLanczosFactor: false,
                        rate: 6000,
                        wave: null
                    };
                    $scope.options = this.options;
                    
                    $scope.$watch("options.wave", function(newWave) {
                        if($scope.options.evaluation.min == 1 && newWave.start == 2) {
                            $scope.options.evaluation.min = 2;
                            $scope.options.evaluation.value++;
                        } else if($scope.options.evaluation.min == 2 && newWave.start == 1) {
                            $scope.options.evaluation.min = 1;
                            $scope.options.evaluation.value--;
                        }
                    });

                    function lanczosFactor(f_number) {
                        if(!$scope.options.useLanczosFactor) return 1;
                        var x = (f_number * Math.PI) / $scope.options.evaluation.value;
                        return Math.sin(x) / x;
                    }                    
                    
                    function basicFourierFunction(theta, f_number) {
                        return ((4 * Math.sin(f_number * theta)) / (f_number * Math.PI)) * lanczosFactor(f_number);
                    }

                    function basicFourierFunctionMax(f_number) {
                        return (4 / (f_number * Math.PI)) * lanczosFactor(f_number);
                    }
                    
                    function triangleFourierFunction(theta, f_number) {
                        return ((8 * (Math.pow(-1, (f_number - 1) / 2) ) * Math.sin( f_number * theta)) / (f_number * f_number * Math.PI * Math.PI)) * lanczosFactor(f_number);
                    }

                    function triangleFourierFunctionMax(f_number) {
                        return Math.abs(((8 * (Math.pow(-1, (f_number - 1) / 2)))  / (f_number * f_number * Math.PI * Math.PI)) * lanczosFactor(f_number));
                    }
                    
                    function triangleFourierFunctionCoef(f_number) {
                        return ((8 * (Math.pow(-1, (f_number - 1) / 2)))  / (f_number * f_number * Math.PI * Math.PI)) * lanczosFactor(f_number);
                    }

                    
                    this.waves = [
                        {
                            name: 'Square',
                            start: 1,
                            actualWave: function (theta) {
                                return (theta % (2 * Math.PI)) > Math.PI? -1: 1;
                            },
                            fourierFunction: basicFourierFunction,
                            fourierFunctionMax: basicFourierFunctionMax,
                            getAudioWaveCoefficients: function(f_pos) {
                                var imag = ((f_pos  % 2) === 1)? basicFourierFunctionMax(f_pos): 0;
                                return [0, imag];
                            }
                        },
                        {
                            name: 'Inverse Sawtooth',
                            start: 2,
                            actualWave: function (theta) {
                                return 1 - ( (theta % (Math.PI)) / (Math.PI / 2));
                            },
                            fourierFunction: basicFourierFunction,
                            fourierFunctionMax: basicFourierFunctionMax,
                            getAudioWaveCoefficients: function(f_pos) {
                                var imag = ((f_pos  % 2) === 0)? basicFourierFunctionMax(f_pos): 0;
                                return [0, imag];
                            }
                        },
                        {
                            name: 'Triangle',
                            start: 1,
                            actualWave: function (theta) {
                                var mod_theta = theta % ( 2 * Math.PI);
                                if(mod_theta > Math.PI / 2 && mod_theta <= (3 * Math.PI) / 2) {
                                    return (1 - ((2/Math.PI) * (mod_theta - (Math.PI/2))));
                                } else if(mod_theta > (3 * Math.PI) / 2) {
                                    return ((2/(Math.PI)) * (mod_theta % Math.PI) ) - 2;
                                } else {
                                    return ((2/Math.PI) * mod_theta);
                                }
                                //return (mod_theta > Math.PI / 2 && mod_theta > (3 * Math.PI) / 2)? (1 - ((2/Math.PI) * (mod_theta - (Math.PI/2)))): ;
                            },
                            fourierFunction: triangleFourierFunction,
                            fourierFunctionMax: triangleFourierFunctionMax,
                            getAudioWaveCoefficients: function(f_pos) {
                                var imag = ((f_pos  % 2) === 1)? -triangleFourierFunctionCoef(f_pos): 0;
                                return [0, imag];
                            }
                        }
                    ];
                    $scope.waves = this.waves;
                    
                    this.options.wave = this.waves[0]
                    
                    this.status = {
                        visualizationPaused: false,
                        step: false,
                        audioPaused: true
                    };
                    $scope.status = this.status;
                    
                    this.scope = $scope;
                }
                
                function FourierAppLink(scope, elm, attrs, app) {
                    
                    document.addEventListener("keydown", function(event) {
                        if(event.keyCode === 80) {
                            app.scope.status.visualizationPaused = !app.scope.status.visualizationPaused;
                        } else if(app.status.visualizationPaused && event.keyCode == 39 ) {
                            app.scope.status.step = true;
                        }
                        app.scope.$digest();
                    });
           
                }
            })
            .directive('dragUpdate', function() {
                return {
                    restrict: 'A',
                    link: function(scope, element, attrs) {
                        element.on('$md.drag', function() {
                            console.info('Drag Ended');
                        })
                    }
                }
            })
            .directive("fourierCanvas", function() {
                return {
                    require: '^fourierApp',
                    template: '<canvas width="1200" height="600"></canvas>',
                    restrict: 'A',
                    link: FourierCanvasLink
                };
                
                
                function FourierCanvasLink(scope, elm, attrs, fourierApp) {
                    var clear = false;
                    
                    
                    fourierApp.scope.$watch('status.visualizationPaused', function(newVal, oldVal) {
                        if(newVal === oldVal) return;
                        
                        if(!newVal) {
                            update();
                        }
                    });
                    
                    fourierApp.scope.$watch('status.step', function(newVal, oldVal) {
                        if(newVal === oldVal) return;
                        
                        if(newVal) {
                            update();
                        }
                    });
                    
                    fourierApp.scope.$watch('options', function(newVal, oldVal) {
                        clear = true;
                    }, true);
                    
                    var TOTAL_HEIGHT = 600;
                    var TOTAL_WIDTH = 1200;
                    var HEIGHT = 120;
                    var LEFT = 750;
                    var WIDTH = 400;
                    var PADDING = 40;
                    
                    var canvasElm = elm[0].querySelector('canvas');

                    /**
                     * @type CanvasRenderingContext2D
                     */
                    var ctx = canvasElm.getContext("2d");
                    

                    var positions = [];

                    var squareWave = [];

                    

                    var TOP = 50;

                    var colors = ['#EF476F', '#605B56', '#FFD166', '#06D6A0', '#712F79'];

                    var useLanczosFactor = fourierApp.options.useLanczosFactor,
                        fourierFunction = fourierApp.options.wave.fourierFunction,
                        fourierFunctionMax = fourierApp.options.wave.fourierFunctionMax;


                    function fourierValue(theta, f_number) {
                        if(f_number <= 0) return 0;
                        
                        var components = new Array(f_number + 1);
                        
                        var total = 0, componentValue = 0;
                        
                        for(; f_number > 0; f_number -= 2) {
                            componentValue = fourierFunction(theta, f_number);
                            total += componentValue;
                            components.splice(f_number, 1, componentValue);
                        }
                        
                        return {
                            components: components,
                            total: total
                        };
                    }


                    function x(value) {
                        return value + LEFT;
                    }

                    function y(value, offset) {
                        if(!offset) {
                            offset = HEIGHT;
                        }
                        return offset + (-value * offset) + TOP;
                    }

                    var prevFValue = 1;


                    var ac = new AudioContext();
                    var osc = ac.createOscillator();
                    osc.frequency.value = 220;

                    function updateAudioWaveTable(f_value) {
                        var parts = [new Float32Array(200), new Float32Array(200)];
                        var result;
                        
                        var f_pos = 0;
                        do {
                            result = fourierApp.options.wave.getAudioWaveCoefficients(f_pos);
                            parts[0][f_pos] = result[0];
                            parts[1][f_pos] = result[1];
                        } while(f_pos++ <= f_value);
                        var wave = ac.createPeriodicWave(parts[0], parts[1]);

                        osc.setPeriodicWave(wave);
                    }


                    fourierApp.scope.$watch('status.audioPaused', function(newVal, oldVal) {
                        if(newVal === oldVal) return;
                        
                        if(!newVal) {
                            osc = ac.createOscillator();
                            osc.frequency.value = 220;
                            osc.connect(ac.destination);
                            updateAudioWaveTable(prevFValue);
                            osc.start();
                        } else {
                            osc.stop();
                        }
                    });
                    
                    function drawArrow(x, y, s, w, color) {
                        ctx.stokeStyle = color;
                        ctx.lineWidth = w;
                        
                        ctx.beginPath();
                        ctx.moveTo(x - s, y - (s * .6));
                        ctx.lineTo(x, y);
                        ctx.lineTo(x - s, y + (s * .6));
                        ctx.stroke();
                    }
                    
                    function drawShadeCircle(cx, cy, r, color, width) {
                        ctx.strokeStyle = color;
                            ctx.fillStyle = '#FFFFFF';
                            ctx.lineWidth = width;
                            ctx.globalAlpha = 0.15;
                            ctx.beginPath();
                            ctx.arc(cx,cy,r,0,2*Math.PI);
                            
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                    }
                   
                    
                    function drawCircle(cx, cy, r, armX, armY, color) {

                        ctx.strokeStyle = color;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(cx,cy,r,0,2*Math.PI);

                        ctx.stroke();

                        ctx.fillStyle = color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(armX, armY);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.arc(armX,armY,Math.max(r / 20, 2),0,2*Math.PI);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    function drawFourierCircle(cx, cy, h, num, theta) {
                        var max_h = fourierFunctionMax(num);
                        
                        var r = Math.max(max_h * h, 0);
                        
                        if(r === 0) {
                            return;
                        }

                        var y_val = fourierFunction(theta, num);
                        
                        var x_val = -fourierFunction(theta + ((Math.PI /2) / num), num);
                        
                        armY = cy + (-y_val * h);
                        
                        armX = cx + (-x_val * h);
                        
                        if(useLanczosFactor) {

                            useLanczosFactor = false;
                            var new_r = h * fourierFunctionMax(num);
                            width = new_r - r;
                            
                            if(width < 0) {
                                width = new_r;
                                new_r = 1;
                            } else {
                                new_r -= width/2;
                            }
                            
                            drawShadeCircle(cx, cy, new_r, colors[num % colors.length], width);
                            useLanczosFactor = true;
                        }

                        drawCircle(cx, cy, r, armX, armY, colors[num % colors.length]);
                        
                        return [armX, armY];
                    }
                    
                    function drawTotalCircles(cx, cy, theta) {
                        var cur_pos;
                        for(var num = fourierApp.options.wave.start; num <= f_value; num+=2, cx = cur_pos[0], cy = cur_pos[1]) {
                            cur_pos = drawFourierCircle(cx, cy, HEIGHT, num, theta);
                        }
                        
                        return cx;
                    }


                    function drawComponents(positions, theta) {
                        
                        var x = 220,
                            top = 500,
                            h = 25,
                            width = 200,
                            history_count = 50,
                            text_top = 420;
                            
                        var val1, val2, cur_pos, r, x_start;
                        
                        var x1, x2, y1, y2;
                        
                        var text_x_start;
                        
                        var angle = (theta % (2* Math.PI));
                        var angleRad = angle.toFixed(2);
                    
                        ctx.fillStyle = "#444";
                        ctx.font = "20px \"Cambria Math\"";
                        ctx.textAlign = "left";
                        ctx.textBaseline = "middle";
                        ctx.fillText("f(\u03B8) = ", 115, text_top);
                        ctx.fillText("f("+ angleRad + "\u33AD) \u2245 " + positions[0].total.toFixed(2) + " \u2245 ", 5, top);
                        ctx.textBaseline = "alphabetic";
                        
                        for(var num = f_value; num >= fourierApp.options.wave.start && x + width < TOTAL_WIDTH; num-=2, x+=width) {
                            cur_pos = drawFourierCircle(x, top, h, num, theta);
                            
                            r = h * fourierFunctionMax(num);
                            x_start = x + (r) + 30;
                            
                            x1 = x_start;
                            
                            ctx.strokeStyle = colors[num % colors.length];
                            ctx.beginPath();
                            
                            for(var index = 0; index < Math.min(positions.length - 1, history_count); index++) {
                                val1 =  positions[index].components[num];
                                val2 =  positions[index + 1].components[num];
                               
                                x2 = x1 + 1;
                                
                                y1 = (-val1 * h) + (top);
                                y2 = (-val2 * h) + (top);
                                
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                
                                x1 = x2;
                            }
                            ctx.stroke();
                            
                            val2 = positions[0].components[num];
                            y2 = (-val2 * h) + (top);
                            
                            ctx.beginPath();
                            ctx.moveTo(cur_pos[0], y2);
                            ctx.lineTo(x_start, y2);
                            ctx.stroke();
                            
                            drawArrow(x_start, y2, 3, 1, colors[num % colors.length]);
                            
                            ctx.beginPath();
                            ctx.moveTo(x_start, top - r);
                            ctx.lineTo(x_start, top + r);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(x_start + history_count, top - r);
                            ctx.lineTo(x_start + history_count, top + r);
                            ctx.stroke();
                            
                            var text_x = x - h;
                            text_x_start = text_x;
                            
                            ctx.font = "10px \"Cambria Math\"";
                            ctx.textAlign = "left";   
                            ctx.textBaseline = "middle";   
                            ctx.fillText(positions[0].components[num].toFixed(2), x_start - 20, y2 - 7);
                            
                            var print_num =  num > 1? num: '';
                            
                            ctx.font = "20px \"Cambria Math\"";
                            ctx.textAlign = "center";   
                            ctx.textBaseline = "alphabetic";   
                            
                            var numerator_text = "4sin(" + print_num + "\u03B8)",
                                denominator_text = print_num + "\u03C0";
                             
                            
                            var measurement = ctx.measureText(numerator_text);
                                
                            text_x += measurement.width / 2;
                            
                            
                            ctx.fillText(numerator_text, text_x, text_top - 10);
                            ctx.fillText(denominator_text, text_x, text_top + 20);
                            
                            
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(text_x_start - 3, text_top);
                            ctx.lineTo(text_x_start + measurement.width + 3, text_top);
                            ctx.stroke();
                            
                            text_x_start += measurement.width + 20;
                            
                            if(num - 2 >= fourierApp.options.wave.start) {
                                ctx.fillStyle = "#444";
                                ctx.font = "40px sans-serif";
                                ctx.textAlign = "left";
                                ctx.textBaseline = "middle";    
                                ctx.fillText("+", text_x_start, text_top);
                                ctx.textBaseline = "alphabetic";
                            }
                        }
                        
                        
                        if(x + (2 * width) > TOTAL_WIDTH && num >= fourierApp.options.wave.start) {
                            ctx.fillStyle = "#444";
                            ctx.font = "40px sans-serif";
                            ctx.textAlign = "left";
                            ctx.textBaseline = "middle";    
                            ctx.fillText("+ \u22EF", text_x_start, top);
                            ctx.textBaseline = "alphabetic";    
                        }
                        
                        
                    }

                    var f_value = fourierApp.options.evaluation.value;
                    var time = 0;
                         
                    function update() {
                        var t1 = performance.now();
                        
                        if(fourierApp.status.visualizationPaused && !fourierApp.status.step) {
                            return;
                        }
                        
                        if(fourierApp.status.step) {
                            fourierApp.status.step = false;
                        }
                        
                        ctx.globalCompositeOperation = 'destination-over';
                        ctx.clearRect(0,0,1200,600); // clear canvas
                       
                        
                        f_value = fourierApp.options.evaluation.value;
                        useLanczosFactor = fourierApp.options.useLanczosFactor;
                        fourierFunction = fourierApp.options.wave.fourierFunction;
                        fourierFunctionMax = fourierApp.options.wave.fourierFunctionMax;

                        time += 16.67;
                        
                        var theta = (((2*Math.PI)/fourierApp.options.rate)*time);
         
                        
                        if(clear) {
                            positions.length = 0;
                            squareWave.length = 0;
                            
                            updateAudioWaveTable(f_value);
                            clear = false;
                        }
                        
                        prevFValue = f_value;
                        
                        positions.unshift(fourierValue(theta, f_value));
                        squareWave.unshift(fourierApp.options.wave.actualWave(theta));
                        
                        if(positions.length > WIDTH) {
                            positions.pop();
                            squareWave.pop();
                        }
                        
                        var positionsCount = positions.length;
                        var x1, x2, y1, y2;
                        
                        ctx.strokeStyle = "#00000";
                        ctx.strokeRect(LEFT, TOP- PADDING, WIDTH, 2*HEIGHT + 2*PADDING);
                        

                        ctx.strokeStyle = "#333";
                        ctx.beginPath();
                        for(var i = 0; i < positionsCount - 1; i++) {
                            x1 = x(i);
                            x2 = x(i + 1);
                            
                            y1 = y(squareWave[i]);
                            y2 = y(squareWave[i + 1]);
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            
                        }
                        ctx.stroke();
                        
                        ctx.strokeStyle = "#000000";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        for(var i = 0; i < positionsCount - 1; i++) {
                            x1 = x(i);
                            x2 = x(i + 1);
                            
                            y1 = y(positions[i].total);
                            y2 = y(positions[i + 1].total);
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                        }
                        
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        drawComponents(positions, theta);
                        
                        var final_cx = drawTotalCircles(300, TOP + HEIGHT, theta);
                        
                        var yPos = y(positions[0].total);
                        
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = "#000000";
                        ctx.beginPath();
                        ctx.moveTo(final_cx, yPos);
                        ctx.lineTo(LEFT, yPos);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                        
                        drawArrow(LEFT, yPos, 7, 2, "#000");
                        
                        frametimes.push(performance.now() -t1);
                        requestAnimationFrame(update);
                    }
                    update();
                }
            });
        </script>
    </body>
</html>